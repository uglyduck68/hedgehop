/*************************************************************
 * This file is for tests that are common to both C and C++
 ************************************************************/

#if ! IS_CLIPPED

/*********************************
 * Tests for FULL ports
 ********************************/


/****************************
 * Core Condor Functionality
 ***************************/

DESC(job_core_bigenv_std,"Standard job with an enormous environment")
CBUILD($(CC),job_core_bigenv,c)
DEPS(job_core_bigenv_std,job_core_bigenv.exe job_core_bigenv.cndr.exe)
DEP_SYMLINK_EXT(job_core_bigenv_std,cmd)
RUN(job_core_bigenv_std)
TESTCLASS(job_core_bigenv_std,framework)
TESTCLASS(job_core_bigenv_std,quick)
TESTCLASS(job_core_bigenv_std,full)


/****************************
 * Remote System Calls
 ***************************/

DESC(job_rsc_all-syscalls_std,"Tests nearly all remote syscalls")
CBUILD($(CC),job_rsc_all-syscalls_std,c)
DEP_SYMLINK_EXT(job_rsc_all-syscalls_std,cmd)
RUN(job_rsc_all-syscalls_std)
TESTCLASS(job_rsc_all-syscalls_std,stduniv)
TESTCLASS(job_rsc_all-syscalls_std,framework)
TESTCLASS(job_rsc_all-syscalls_std,critical)
TESTCLASS(job_rsc_all-syscalls_std,quick)
TESTCLASS(job_rsc_all-syscalls_std,full)
TESTCLASS(job_rsc_all-syscalls_std,rsc)

DESC(job_rsc_hello_std,"Tests various RSC I/O methods")
CBUILD($(CC),job_rsc_hello_std,c)
DEPS(job_rsc_hello_std,x_hello.in)
DEP_SYMLINK_EXT(job_rsc_hello_std,cmd)
RUN(job_rsc_hello_std)
TESTCLASS(job_rsc_hello_std,stduniv)
TESTCLASS(job_rsc_hello_std,framework)
TESTCLASS(job_rsc_hello_std,quick)
TESTCLASS(job_rsc_hello_std,full)
TESTCLASS(job_rsc_hello_std,rsc)

DESC(job_rsc_fcntl_std,"Does fcntl() work remotely?")
CBUILD($(CC),job_rsc_fcntl_std,c)
DEP_SYMLINK_EXT(job_rsc_fcntl_std,cmd)
RUN(job_rsc_fcntl_std)
TESTCLASS(job_rsc_fcntl_std,stduniv)
TESTCLASS(job_rsc_fcntl_std,framework)
TESTCLASS(job_rsc_fcntl_std,quick)
TESTCLASS(job_rsc_fcntl_std,full)
TESTCLASS(job_rsc_fcntl_std,rsc)

DESC(job_rsc_truncate_std,"Can we truncate files with open() remotely?")
CBUILD($(CC),job_rsc_truncate_std,c)
DEP_SYMLINK_EXT(job_rsc_truncate_std,cmd)
RUN(job_rsc_truncate_std)
TESTCLASS(job_rsc_truncate_std,stduniv)
TESTCLASS(job_rsc_truncate_std,framework)
TESTCLASS(job_rsc_truncate_std,quick)
TESTCLASS(job_rsc_truncate_std,full)
TESTCLASS(job_rsc_truncate_std,rsc)

#if HAVE_GETDIRENTRIES && ! IS_HPUX
/* even though HPUX has getdirentries(), our test program doesn't
   build a valid test for it and the code is all #ifdef'ed out.  so,
   until someone fixes the test, there's no reason to run it here.
*/
DESC(job_rsc_getdirentries_std,"Does getdirentries() work remotely?")
CBUILD($(CC),job_rsc_getdirentries_std,c)
DEP_SYMLINK_EXT(job_rsc_getdirentries_std,cmd)
RUN(job_rsc_getdirentries_std)
TESTCLASS(job_rsc_getdirentries_std,stduniv)
TESTCLASS(job_rsc_getdirentries_std,quick)
TESTCLASS(job_rsc_getdirentries_std,full)
TESTCLASS(job_rsc_getdirentries_std,rsc)
#endif /* HAVE_GETDIRENTRIES */

DESC(job_rsc_fgets_std,"Does fgets() work remotely?")
CBUILD($(CC),job_rsc_fgets_std,c)
DEPS(job_rsc_fgets_std,x_data.in)
DEP_SYMLINK_EXT(job_rsc_fgets_std,cmd)
RUN(job_rsc_fgets_std)
TESTCLASS(job_rsc_fgets_std,stduniv)
TESTCLASS(job_rsc_fgets_std,framework)
TESTCLASS(job_rsc_fgets_std,long)
TESTCLASS(job_rsc_fgets_std,full)
TESTCLASS(job_rsc_fgets_std,rsc)

DESC(job_rsc_fread_std,"Does fread() work remotely?")
CBUILD($(CC),job_rsc_fread_std,c)
DEPS(job_rsc_fread_std,x_data.in)
DEP_SYMLINK_EXT(job_rsc_fread_std,cmd)
RUN(job_rsc_fread_std)
TESTCLASS(job_rsc_fread_std,stduniv)
TESTCLASS(job_rsc_fread_std,framework)
TESTCLASS(job_rsc_fread_std,long)
TESTCLASS(job_rsc_fread_std,full)
TESTCLASS(job_rsc_fread_std,rsc)

DESC(job_rsc_ftell_std,"Does ftell() work remotely?")
CBUILD($(CC),job_rsc_ftell_std,c)
DEPS(job_rsc_ftell_std,x_data.in)
DEP_SYMLINK_EXT(job_rsc_ftell_std,cmd)
RUN(job_rsc_ftell_std)
TESTCLASS(job_rsc_ftell_std,stduniv)
TESTCLASS(job_rsc_ftell_std,framework)
TESTCLASS(job_rsc_ftell_std,quick)
TESTCLASS(job_rsc_ftell_std,full)
TESTCLASS(job_rsc_ftell_std,rsc)

DESC(job_rsc_open-N-serial_std,"Can we open/close N files in serial?")
CBUILD($(CC),job_rsc_open-N-serial_std,c)
DEP_SYMLINK_EXT(job_rsc_open-N-serial_std,cmd)
RUN(job_rsc_open-N-serial_std)
TESTCLASS(job_rsc_open-N-serial_std,stduniv)
TESTCLASS(job_rsc_open-N-serial_std,framework)
TESTCLASS(job_rsc_open-N-serial_std,quick)
TESTCLASS(job_rsc_open-N-serial_std,full)
TESTCLASS(job_rsc_open-N-serial_std,rsc)

DESC(job_rsc_atexit_std,"Does atexit() still work?")
CBUILD($(CC),job_rsc_atexit_std,c)
DEP_SYMLINK_EXT(job_rsc_atexit_std,cmd)
RUN(job_rsc_atexit_std)
TESTCLASS(job_rsc_atexit_std,stduniv)
TESTCLASS(job_rsc_atexit_std,framework)
TESTCLASS(job_rsc_atexit_std,quick)
TESTCLASS(job_rsc_atexit_std,full)
TESTCLASS(job_rsc_atexit_std,rsc)

DESC(job_rsc_stat_std,"Does stat() work remotely?")
CBUILD($(CC),job_rsc_stat_std,c)
DEPS(job_rsc_stat_std,x_data.in)
DEP_SYMLINK_EXT(job_rsc_stat_std,cmd)
RUN(job_rsc_stat_std)
TESTCLASS(job_rsc_stat_std,stduniv)
TESTCLASS(job_rsc_stat_std,framework)
TESTCLASS(job_rsc_stat_std,quick)
TESTCLASS(job_rsc_stat_std,full)
TESTCLASS(job_rsc_stat_std,rsc)

DESC(job_rsc_zero-calloc_std,"Does calloc() allocated zero'ed-out memory?")
CBUILD($(CC),job_rsc_zero-calloc_std,c)
DEP_SYMLINK_EXT(job_rsc_zero-calloc_std,cmd)
RUN(job_rsc_zero-calloc_std)
TESTCLASS(job_rsc_zero-calloc_std,stduniv)
TESTCLASS(job_rsc_zero-calloc_std,framework)
TESTCLASS(job_rsc_zero-calloc_std,long)
TESTCLASS(job_rsc_zero-calloc_std,full)
TESTCLASS(job_rsc_zero-calloc_std,rsc)


/****************************
 * Checkpointing
 ***************************/

DESC(job_ckpt_combo-sanity_std,"combination of sbrk() and register inspection for overall ckpt sanity")
CBUILD($(CC),job_ckpt_combo-sanity_std,c)
DEP_SYMLINK_EXT(job_ckpt_combo-sanity_std,cmd)
RUN(job_ckpt_combo-sanity_std)
TESTCLASS(job_ckpt_combo-sanity_std,stduniv)
TESTCLASS(job_ckpt_combo-sanity_std,long)
TESTCLASS(job_ckpt_combo-sanity_std,full)
TESTCLASS(job_ckpt_combo-sanity_std,ckpt)

DESC(job_ckpt_io-async_std,"file I/O during async ckpt signals")
CBUILD($(CC),job_ckpt_io-async_std,c)
DEP_SYMLINK_EXT(job_ckpt_io-async_std,cmd)
RUN(job_ckpt_io-async_std)
TESTCLASS(job_ckpt_io-async_std,stduniv)
TESTCLASS(job_ckpt_io-async_std,quick)
TESTCLASS(job_ckpt_io-async_std,full)
TESTCLASS(job_ckpt_io-async_std,ckpt)

DESC(job_ckpt_io-buffer-async_std,"file buffing during async ckpt/restore")
CBUILD_DEP($(CC),job_ckpt_io-buffer-async_std,c,x_waste_second.o)
DEP_SYMLINK_EXT(job_ckpt_io-buffer-async_std,cmd)
RUN(job_ckpt_io-buffer-async_std)
TESTCLASS(job_ckpt_io-buffer-async_std,stduniv)
TESTCLASS(job_ckpt_io-buffer-async_std,quick)
TESTCLASS(job_ckpt_io-buffer-async_std,full)
TESTCLASS(job_ckpt_io-buffer-async_std,ckpt)

DESC(job_ckpt_stack_std,"ckpt/restore function call stack")
CBUILD($(CC),job_ckpt_stack_std,c)
DEP_SYMLINK_EXT(job_ckpt_stack_std,cmd)
RUN(job_ckpt_stack_std)
TESTCLASS(job_ckpt_stack_std,stduniv)
TESTCLASS(job_ckpt_stack_std,framework)
TESTCLASS(job_ckpt_stack_std,quick)
TESTCLASS(job_ckpt_stack_std,full)
TESTCLASS(job_ckpt_stack_std,ckpt)

DESC(job_ckpt_floats_std,"ckpt/restore floating point registers")
CBUILD($(CC),job_ckpt_floats_std,c)
DEP_SYMLINK_EXT(job_ckpt_floats_std,cmd)
RUN(job_ckpt_floats_std)
TESTCLASS(job_ckpt_floats_std,stduniv)
TESTCLASS(job_ckpt_floats_std,framework)
TESTCLASS(job_ckpt_floats_std,quick)
TESTCLASS(job_ckpt_floats_std,full)
TESTCLASS(job_ckpt_floats_std,ckpt)

DESC(job_ckpt_floats-async_std,"checks floating point ops with async ckpts")
CBUILD($(CC),job_ckpt_floats-async_std,c)
DEP_SYMLINK_EXT(job_ckpt_floats-async_std,cmd)
RUN(job_ckpt_floats-async_std)
TESTCLASS(job_ckpt_floats-async_std,stduniv)
TESTCLASS(job_ckpt_floats-async_std,framework)
TESTCLASS(job_ckpt_floats-async_std,quick)
TESTCLASS(job_ckpt_floats-async_std,full)
TESTCLASS(job_ckpt_floats-async_std,ckpt)

DESC(job_ckpt_integers_std,"ckpt/restore integer registers")
CBUILD($(CC),job_ckpt_integers_std,c)
DEP_SYMLINK_EXT(job_ckpt_integers_std,cmd)
RUN(job_ckpt_integers_std)
TESTCLASS(job_ckpt_integers_std,stduniv)
TESTCLASS(job_ckpt_integers_std,framework)
TESTCLASS(job_ckpt_integers_std,quick)
TESTCLASS(job_ckpt_integers_std,full)
TESTCLASS(job_ckpt_integers_std,ckpt)

#if DOES_SAVE_SIGSTATE
DESC(job_ckpt_signals_std,"ckpt/restore signal state")
CBUILD($(CC),job_ckpt_signals_std,c)
DEP_SYMLINK_EXT(job_ckpt_signals_std,cmd)
RUN(job_ckpt_signals_std)
TESTCLASS(job_ckpt_signals_std,stduniv)
TESTCLASS(job_ckpt_signals_std,quick)
TESTCLASS(job_ckpt_signals_std,full)
TESTCLASS(job_ckpt_signals_std,ckpt)
#endif /* DOES_SAVE_SIGSTATE */

DESC(job_ckpt_dup_std,"ckpt/restore file table state with dup() calls")
CBUILD($(CC),job_ckpt_dup_std,c)
DEPS(job_ckpt_dup_std,x_data.in)
DEP_SYMLINK_EXT(job_ckpt_dup_std,cmd)
RUN(job_ckpt_dup_std)
TESTCLASS(job_ckpt_dup_std,stduniv)
TESTCLASS(job_ckpt_dup_std,quick)
TESTCLASS(job_ckpt_dup_std,full)
TESTCLASS(job_ckpt_dup_std,ckpt)

#if ! IS_DARWIN
DESC(job_ckpt_longjmp_std,"Can we ckpt while longjmp()'ing around?")
CBUILD_DEP($(CC),job_ckpt_longjmp_std,c,x_waste_second.o)
DEP_SYMLINK_EXT(job_ckpt_longjmp_std,cmd)
RUN(job_ckpt_longjmp_std)
TESTCLASS(job_ckpt_longjmp_std,stduniv)
TESTCLASS(job_ckpt_longjmp_std,long)
TESTCLASS(job_ckpt_longjmp_std,full)
TESTCLASS(job_ckpt_longjmp_std,ckpt)
#endif

DESC(job_ckpt_gettimeofday_std,"ckpt/restore current time-of-day")
CBUILD_DEP($(CC),job_ckpt_gettimeofday_std,c,x_waste_second.o)
DEP_SYMLINK_EXT(job_ckpt_gettimeofday_std,cmd)
RUN(job_ckpt_gettimeofday_std)
TESTCLASS(job_ckpt_gettimeofday_std,stduniv)
TESTCLASS(job_ckpt_gettimeofday_std,long)
TESTCLASS(job_ckpt_gettimeofday_std,full)
TESTCLASS(job_ckpt_gettimeofday_std,ckpt)

DESC(job_ckpt_open-async-ckpt_std,"async ckpt/restore of open file table")
CBUILD($(CC),job_ckpt_open-async-ckpt_std,c)
DEP_SYMLINK_EXT(job_ckpt_open-async-ckpt_std,cmd)
RUN(job_ckpt_open-async-ckpt_std)
TESTCLASS(job_ckpt_open-async-ckpt_std,stduniv)
TESTCLASS(job_ckpt_open-async-ckpt_std,quick)
TESTCLASS(job_ckpt_open-async-ckpt_std,full)
TESTCLASS(job_ckpt_open-async-ckpt_std,ckpt)

DESC(job_ckpt_open-N-parallel_std,"ckpt/restore of N files open at once")
CBUILD($(CC),job_ckpt_open-N-parallel_std,c)
DEP_SYMLINK_EXT(job_ckpt_open-N-parallel_std,cmd)
DEPS(job_ckpt_open-N-parallel_std,x_data-1.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-2.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-3.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-4.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-5.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-6.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-7.in)
DEPS(job_ckpt_open-N-parallel_std,x_data-8.in)
RUN(job_ckpt_open-N-parallel_std)
TESTCLASS(job_ckpt_open-N-parallel_std,stduniv)
TESTCLASS(job_ckpt_open-N-parallel_std,quick)
TESTCLASS(job_ckpt_open-N-parallel_std,full)
TESTCLASS(job_ckpt_open-N-parallel_std,ckpt)

DESC(job_ckpt_getrusage-loop_std,"Does getrusage() work across ckpts?")
CBUILD_DEP($(CC),job_ckpt_getrusage-loop_std,c,x_waste_second.o)
DEP_SYMLINK_EXT(job_ckpt_getrusage-loop_std,cmd)
/* 
this is a terrible idea, but i'm commenting out this test so it
doesn't keep running.  there's a bug in condor's getrusage() support
which this test is noticing but no one's bothered to ever fix it.  so,
for now, instead of seeing failed tests every night, we'll just know
it's broken and stop running it.
RUN(job_ckpt_getrusage-loop_std)
*/

DESC(job_ckpt_socket-support_std,"Do we support sockets around ckpt/restore?")
CBUILD($(CC),job_ckpt_socket-support_std,c)
DEP_SYMLINK_EXT(job_ckpt_socket-support_std,cmd)
RUN(job_ckpt_socket-support_std)
TESTCLASS(job_ckpt_socket-support_std,stduniv)
TESTCLASS(job_ckpt_socket-support_std,long)
TESTCLASS(job_ckpt_socket-support_std,full)
TESTCLASS(job_ckpt_socket-support_std,ckpt)

#endif /* ! IS_CLIPPED */
