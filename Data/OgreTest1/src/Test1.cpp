/*
-----------------------------------------------------------------------------
Filename:    Test1.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#include "StdAfx.h"

#include "Test1.h"
#include "Debug.h"
#include "DebugDrawer.h"

//-------------------------------------------------------------------------------------
Test1::Test1(void) : 
	m_bRotateX(false), m_bRotateY(false), m_bRotateZ(false),
	m_rRotateX(0.0), m_rRotateY(0.0), m_rRotateZ(0.0)
{
}
//-------------------------------------------------------------------------------------
Test1::~Test1(void)
{
}

//-------------------------------------------------------------------------------------
void Test1::createScene(void)
{
    Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");

    Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode("HeadNode");
    headNode->attachObject(ogreHead);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);

	// create axis for debugging
	Ogre::ManualObject*	mAxis	= mSceneMgr->createManualObject("MyAxis");

	mAxis->begin( "AxisMaterial", Ogre::RenderOperation::OT_LINE_LIST );
	mAxis->position(10,0,0);
	mAxis->colour(1,0,0);		// red for x-axis
	mAxis->position(400,0,0);
	mAxis->position(0,10,0);
	mAxis->colour(0,1,0);		// green for y-axis
	mAxis->position(0,400,0);
	mAxis->position(0,0,10);
	mAxis->colour(0,0,1);		// blue for z-axis
	mAxis->position(0,0,400);
	mAxis->end();
    Ogre::SceneNode* axisNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    axisNode->attachObject(mAxis);




	// Sean, create DebugDrawer for debugging
	new DebugDrawer(mSceneMgr, 0.1f);
}

void Test1::destroyScene(void)
{
	delete DebugDrawer::getSingletonPtr();
}

bool Test1::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	bool	bRet	= false;

	// render the default
	bRet	= BaseApplication::frameRenderingQueued(evt);


	return bRet;
}


bool Test1::frameStarted(const Ogre::FrameEvent& evt)
{
	DebugPrintf("Debug: frameStarted: %10.6f\n", evt.timeSinceLastFrame);

	// render debug object
	DebugDrawer::getSingleton().drawCuboid(mSceneMgr->getEntity("Head")->getBoundingBox().getAllCorners(),
		Ogre::ColourValue::Red, true);

	// right before the frame is rendered, call DebugDrawer::build()
	DebugDrawer::getSingleton().build();

	Ogre::SceneNode*	pNode	= mSceneMgr->getSceneNode("HeadNode");

	if( pNode && m_bRotateX )
	{
		m_rRotateX	+=	ROTATE_ANGLE_PER_SEC;

		pNode->pitch(Ogre::Radian(m_rRotateX));
	}

	if( pNode && m_bRotateY )
	{
		m_rRotateY	+=	ROTATE_ANGLE_PER_SEC;

		pNode->yaw(Ogre::Radian(m_rRotateY));
	}

	if( pNode && m_bRotateZ )
	{
		m_rRotateZ	+=	ROTATE_ANGLE_PER_SEC;

		pNode->yaw(Ogre::Radian(m_rRotateZ));
	}

	return true;
}

bool Test1::frameEnded(const Ogre::FrameEvent& evt)
{
	DebugPrintf("Debug: frameEndd: %10.6f\n", evt.timeSinceLastFrame);

	DebugDrawer::getSingleton().clear();

	return true;
}

bool  Test1::keyPressed(const OIS::KeyEvent &arg)
{
	BaseApplication::keyPressed(arg);

    switch (arg.key)   
	{
	case OIS::KC_X:
		m_bRotateX	= true;
		break;
	case OIS::KC_Y:
		m_bRotateY	= true;
		break;
	case OIS::KC_Z:
		m_bRotateZ	= true;
		break;
	}

	return true;
}

bool  Test1::keyReleased(const OIS::KeyEvent &arg)
{
	BaseApplication::keyReleased(arg);

    switch (arg.key)   
	{
	case OIS::KC_X:
		m_bRotateX	= false;
		break;
	case OIS::KC_Y:
		m_bRotateY	= false;
		break;
	case OIS::KC_Z:
		m_bRotateZ	= false;
		break;
	}
	return true;
}
