/*
-----------------------------------------------------------------------------
Filename:    TestHydraXSkyX.h
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#ifndef __TestHydraXSkyX_h_
#define __TestHydraXSkyX_h_

#include <Ogre/Terrain/OgreTerrain.h>
#include <Ogre/Terrain/OgreTerrainGroup.h>

#include <Skyx\SkyX.h>

#include "BaseApplication.h"
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#include "../res/resource.h"
#endif

#include "Hydrax/Hydrax.h"
#include "Hydrax/Noise/Perlin/Perlin.h"
#include "Hydrax/Modules/ProjectedGrid/ProjectedGrid.h"
#include "Hydrax/Modules\/SimpleGrid/SimpleGrid.h"

using namespace	Ogre;

#define	CAMERA_MIN_Y_ON_OCEAN	100
#define		TIME_INTERVAL_1_SEC		(0.1)		// 1 second

/** SkyX settings struct
    @remarks These just are the most important SkyX parameters, not all SkyX parameters.
 */
struct SkyXSettings
{
	/** Constructor
	    @remarks Skydome + vol. clouds + lightning settings
	 */
	SkyXSettings(const Ogre::Vector3 t, const Ogre::Real& tm, const Ogre::Real& mp, const SkyX::AtmosphereManager::Options& atmOpt,
		const bool& lc, const bool& vc, const Ogre::Real& vcws, const bool& vcauto, const Ogre::Radian& vcwd, 
		const Ogre::Vector3& vcac, const Ogre::Vector4& vclr,  const Ogre::Vector4& vcaf, const Ogre::Vector2& vcw,
		const bool& vcl, const Ogre::Real& vclat, const Ogre::Vector3& vclc, const Ogre::Real& vcltm)
		: time(t), timeMultiplier(tm), moonPhase(mp), atmosphereOpt(atmOpt), layeredClouds(lc), volumetricClouds(vc), vcWindSpeed(vcws)
		, vcAutoupdate(vcauto), vcWindDir(vcwd), vcAmbientColor(vcac), vcLightResponse(vclr), vcAmbientFactors(vcaf), vcWheater(vcw)
		, vcLightnings(vcl), vcLightningsAT(vclat), vcLightningsColor(vclc), vcLightningsTM(vcltm)
	{}

	/** Constructor
	    @remarks Skydome + vol. clouds
	 */
	SkyXSettings(const Ogre::Vector3 t, const Ogre::Real& tm, const Ogre::Real& mp, const SkyX::AtmosphereManager::Options& atmOpt,
		const bool& lc, const bool& vc, const Ogre::Real& vcws, const bool& vcauto, const Ogre::Radian& vcwd, 
		const Ogre::Vector3& vcac, const Ogre::Vector4& vclr,  const Ogre::Vector4& vcaf, const Ogre::Vector2& vcw)
		: time(t), timeMultiplier(tm), moonPhase(mp), atmosphereOpt(atmOpt), layeredClouds(lc), volumetricClouds(vc), vcWindSpeed(vcws)
		, vcAutoupdate(vcauto), vcWindDir(vcwd), vcAmbientColor(vcac), vcLightResponse(vclr), vcAmbientFactors(vcaf), vcWheater(vcw), vcLightnings(false)
	{}

	/** Constructor
	    @remarks Skydome settings
	 */
	SkyXSettings(const Ogre::Vector3 t, const Ogre::Real& tm, const Ogre::Real& mp, const SkyX::AtmosphereManager::Options& atmOpt, const bool& lc)
		: time(t), timeMultiplier(tm), moonPhase(mp), atmosphereOpt(atmOpt), layeredClouds(lc), volumetricClouds(false), vcLightnings(false)
	{}

	/// Time
	Ogre::Vector3 time;
	/// Time multiplier
	Ogre::Real timeMultiplier;
	/// Moon phase
	Ogre::Real moonPhase;
	/// Atmosphere options
	SkyX::AtmosphereManager::Options atmosphereOpt;
	/// Layered clouds?
	bool layeredClouds;
	/// Volumetric clouds?
	bool volumetricClouds;
	/// VClouds wind speed
	Ogre::Real vcWindSpeed;
	/// VClouds autoupdate
	bool vcAutoupdate;
	/// VClouds wind direction
	Ogre::Radian vcWindDir;
	/// VClouds ambient color
	Ogre::Vector3 vcAmbientColor;
	/// VClouds light response
	Ogre::Vector4 vcLightResponse;
	/// VClouds ambient factors
	Ogre::Vector4 vcAmbientFactors;
	/// VClouds wheater
	Ogre::Vector2 vcWheater;
	/// VClouds lightnings?
	bool vcLightnings;
	/// VClouds lightnings average aparition time
	Ogre::Real vcLightningsAT;
	/// VClouds lightnings color
	Ogre::Vector3 vcLightningsColor;
	/// VClouds lightnings time multiplier
	Ogre::Real vcLightningsTM;
};



class TestHydraXSkyX : public BaseApplication
{
public:
    TestHydraXSkyX(void);
    virtual ~TestHydraXSkyX(void);

protected:
    virtual void createScene(void);
	virtual void createFrameListener();
	virtual void chooseSceneManager();
	virtual bool frameStarted(const FrameEvent &e);
	virtual bool frameRenderingQueued(const Ogre::FrameEvent& e);
	virtual bool keyPressed( const OIS::KeyEvent &arg );
	virtual bool keyReleased( const OIS::KeyEvent &arg );

	void createTextArea();
	Ogre::String buildInfoStr();
	void setPreset(const SkyXSettings& preset);


	void InitLight(void);
	void InitHydrax(Ogre::RenderWindow* window, Ogre::Camera* camera);

	void InitCamera();

private:
	// ----------------------------------------------------------------------------
	// SkyX-related ptrs
	// ----------------------------------------------------------------------------
	SkyX::SkyX* mSkyX;
	SkyX::BasicController* mBasicController;

	// ----------------------------------------------------------------------------
	// Misc
	// ----------------------------------------------------------------------------
	Ogre::TextAreaOverlayElement* mTextArea;
	Ogre::uint32	mCurrentPreset;
//	Ogre::Camera*	mRenderingCamera;
    Real			mKeyBuffer;


	// ----------------------------------------------------------------------------
	// HydraX-related ptrs
	// ----------------------------------------------------------------------------
	Ogre::Terrain* m_terrain;
	Ogre::TerrainGlobalOptions* m_terrainGlobals;
	Ogre::Light* m_light;

	Hydrax::Hydrax* m_hydrax;

	// ----------------------------------------------------------------------------
	// Target-related ptrs
	// ----------------------------------------------------------------------------
    Ogre::Entity*		m_Ship;
    Ogre::SceneNode*	m_ShipNode;

	//< coordinate of 3D circle
	std::deque<Vector3> m_WalkList;		// set of waypoint
	Real				mDistance;		// 다음 지점까지 남은 거리
	Vector3				mDirection;		// 객체가 움직이고 있는 방향
	Vector3				mDestination;	// 객체가 가고 있는 목표점

	/*
	* for 부드러운 회전
	* 원래는 100 이였으나 속도가 너무 빨라 TIME_INTERVAL_1_SEC 시간 동안
	* 회전해야할 부분을 넘어서게 된다. 따라서 속도롤 줄인다.
	*/
	static const int	m_WalkSpeed		= 100;	// character speed. change speed to 10 from 100.
	static const int	MAX_INDEX		= 100;	// # of points that make up circle. change speed to 50 from 100.
	
	// 두 지점 사이의 이동 시 m_ElapseTime 시간내에 이루어져야 한다.
	Real					m_ElapsedTime;

	/**
	* 부드러운 회전을 위한 변수 선언
	*/
	bool					mRotating;		// 현재 구면보간을 이용하여 회전 중인가?
	Quaternion				mSrcQuat;
	Quaternion				mDestQuat;
	Real					mRotatingTime;	// 회전 경과 시간

	void makeAnimationRoute();

	Ogre::SceneNode* GetSceneNode()
	{
		return m_ShipNode;
	}

	bool nextLocation(Real& distance);
	bool MoveShip(const Ogre::FrameEvent& e);
};

#endif // #ifndef __TestHydraXSkyX_h_
