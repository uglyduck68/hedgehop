/*
-----------------------------------------------------------------------------
Filename:    TestHydraXSkyX.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#include <OgreTextAreaOverlayElement.h>

#include "TestHydraXSkyX.h"


/** Demo presets
    @remarks The best way of determinate each parameter value is by using a real-time editor.
			 These presets have been quickly designed using the Paradise Editor, which is a commercial solution.
			 At the time I'm writting these lines, SkyX 0.1 is supported by Ogitor. Hope that the Ogitor team will 
			 support soon SkyX 0.4, this way you all are going to be able to quickly create cool SkyX configurations.
 */
SkyXSettings mPresets[] = {
	// Sunset
	SkyXSettings(Ogre::Vector3(8.85f, 7.5f, 20.5f),  -0.08f, 0, SkyX::AtmosphereManager::Options(9.77501f, 10.2963f, 0.01f, 0.0022f, 0.000675f, 30, Ogre::Vector3(0.57f, 0.52f, 0.44f), -0.991f, 3, 4), false, true, 300, false, Ogre::Radian(270), Ogre::Vector3(0.63f,0.63f,0.7f), Ogre::Vector4(0.35, 0.2, 0.92, 0.1), Ogre::Vector4(0.4, 0.7, 0, 0), Ogre::Vector2(0.8,1)),
	// Clear
	SkyXSettings(Ogre::Vector3(17.16f, 7.5f, 20.5f), 0, 0, SkyX::AtmosphereManager::Options(9.77501f, 10.2963f, 0.01f, 0.0017f, 0.000675f, 30, Ogre::Vector3(0.57f, 0.54f, 0.44f), -0.991f, 2.5f, 4), false),
	// Thunderstorm 1
	SkyXSettings(Ogre::Vector3(12.23, 7.5f, 20.5f),  0, 0, SkyX::AtmosphereManager::Options(9.77501f, 10.2963f, 0.01f, 0.00545f, 0.000375f, 30, Ogre::Vector3(0.55f, 0.54f, 0.52f), -0.991f, 1, 4), false, true, 300, false, Ogre::Radian(0), Ogre::Vector3(0.63f,0.63f,0.7f), Ogre::Vector4(0.25, 0.4, 0.5, 0.1), Ogre::Vector4(0.45, 0.3, 0.6, 0.1), Ogre::Vector2(1,1), true, 0.5, Ogre::Vector3(1,0.976,0.92), 2),
	// Thunderstorm 2
	SkyXSettings(Ogre::Vector3(10.23, 7.5f, 20.5f),  0, 0, SkyX::AtmosphereManager::Options(9.77501f, 10.2963f, 0.01f, 0.00545f, 0.000375f, 30, Ogre::Vector3(0.55f, 0.54f, 0.52f), -0.991f, 0.5, 4), false, true, 300, false, Ogre::Radian(0), Ogre::Vector3(0.63f,0.63f,0.7f), Ogre::Vector4(0, 0.02, 0.34, 0.24), Ogre::Vector4(0.29, 0.3, 0.6, 1), Ogre::Vector2(1,1), true, 0.5, Ogre::Vector3(0.95,1,1), 2),
	// Desert
	SkyXSettings(Ogre::Vector3(7.59f, 7.5f, 20.5f), 0, -0.8f, SkyX::AtmosphereManager::Options(9.77501f, 10.2963f, 0.01f, 0.0072f, 0.000925f, 30, Ogre::Vector3(0.71f, 0.59f, 0.53f), -0.997f, 2.5f, 1), true),
	// Night
	SkyXSettings(Ogre::Vector3(21.5f, 7.5, 20.5), 0.03, -0.25, SkyX::AtmosphereManager::Options(), true)
};

Ogre::String TestHydraXSkyX::buildInfoStr()
{
	Ogre::String str = "SkyX 0.4 demo - Select preset: [1] Desert, [2] Clear, [3] Thunderstorm (1), [4] Thunderstorm (2), [5] Sunset, [6] Night\nCurrent preset: ";

	switch (mCurrentPreset)
	{
		case 0: {str += "1 - Sunset";} break;
		case 1: {str += "2 - Clear";} break;
		case 2: {str += "3 - Thunderstorm (1)";} break;
		case 3: {str += "4 - Thunderstorm (2)";} break;
		case 4: {str += "5 - Desert";} break;
		case 5: {str += "6 - Night";} break;
	}

	return str;
}

void TestHydraXSkyX::setPreset(const SkyXSettings& preset)
{
	mSkyX->setTimeMultiplier(preset.timeMultiplier);
	mBasicController->setTime(preset.time);
	mBasicController->setMoonPhase(preset.moonPhase);
	mSkyX->getAtmosphereManager()->setOptions(preset.atmosphereOpt);

	// Layered clouds
	if (preset.layeredClouds)
	{
		// Create layer cloud
		if (mSkyX->getCloudsManager()->getCloudLayers().empty())
		{
			mSkyX->getCloudsManager()->add(SkyX::CloudLayer::Options(/* Default options */));
		}
	}
	else
	{
		// Remove layer cloud
		if (!mSkyX->getCloudsManager()->getCloudLayers().empty())
		{
			mSkyX->getCloudsManager()->removeAll();
		}
	}

	mSkyX->getVCloudsManager()->setWindSpeed(preset.vcWindSpeed);
	mSkyX->getVCloudsManager()->setAutoupdate(preset.vcAutoupdate);

	SkyX::VClouds::VClouds* vclouds = mSkyX->getVCloudsManager()->getVClouds();

	vclouds->setWindDirection(preset.vcWindDir);
	vclouds->setAmbientColor(preset.vcAmbientColor);
	vclouds->setLightResponse(preset.vcLightResponse);
	vclouds->setAmbientFactors(preset.vcAmbientFactors);
	vclouds->setWheater(preset.vcWheater.x, preset.vcWheater.y, false);

	if (preset.volumetricClouds)
	{
		// Create VClouds
		if (!mSkyX->getVCloudsManager()->isCreated())
		{
			// SkyX::MeshManager::getSkydomeRadius(...) works for both finite and infinite(=0) camera far clip distances
			mSkyX->getVCloudsManager()->create(mSkyX->getMeshManager()->getSkydomeRadius(mCamera));
		}
	}
	else
	{
		// Remove VClouds
		if (mSkyX->getVCloudsManager()->isCreated())
		{
			mSkyX->getVCloudsManager()->remove();
		}
	}

	vclouds->getLightningManager()->setEnabled(preset.vcLightnings);
	vclouds->getLightningManager()->setAverageLightningApparitionTime(preset.vcLightningsAT);
	vclouds->getLightningManager()->setLightningColor(preset.vcLightningsColor);
	vclouds->getLightningManager()->setLightningTimeMultiplier(preset.vcLightningsTM);

	mTextArea->setCaption(buildInfoStr());

	// Reset camera position/orientation
//	mRenderingCamera->setPosition(0,0,0);

//	if (mCurrentPreset == 5)
//		// In Sunset prevent sun light is disappeared
//		mCamera->setDirection(0,0,1);

	mSkyX->update(0);
}



//-------------------------------------------------------------------------------------
TestHydraXSkyX::TestHydraXSkyX(void) : mSkyX(nullptr), mBasicController(nullptr),
	mTextArea(nullptr), mCurrentPreset(0), /*mRenderingCamera(nullptr),*/
	mKeyBuffer(-1),
	m_terrain(nullptr),
	m_terrainGlobals(nullptr),
	m_hydrax(nullptr),
	m_Ship(nullptr), m_ShipNode(nullptr), 	m_ElapsedTime(TIME_INTERVAL_1_SEC),
	mDirection(Vector3::ZERO), mRotating(false), mRotatingTime(0.0f)

{
}
//-------------------------------------------------------------------------------------
TestHydraXSkyX::~TestHydraXSkyX(void)
{
	OGRE_DELETE m_terrainGlobals;
	m_terrainGlobals = NULL;
}

void TestHydraXSkyX::InitCamera()
{
	if (mCamera)
	{
		// set camera position on the ocean
		mCamera->setPosition(0, CAMERA_MIN_Y_ON_OCEAN, 0);

		// set camera to z-axis for sun set
		mCamera->setDirection(0,0,0);
//		mCamera->lookAt(0, 0, 0);
	}
}


void TestHydraXSkyX::InitLight(void)
{
	// Lumi?e directionnelle
	Ogre::Vector3 lightdir(0.55, -0.3, 0.75);
	lightdir.normalise();
	m_light = mSceneMgr->createLight("tstLight");
	m_light->setType(Ogre::Light::LT_DIRECTIONAL);
	m_light->setDirection(lightdir);
	m_light->setDiffuseColour(Ogre::ColourValue::White);
	m_light->setSpecularColour(Ogre::ColourValue(0.8, 0.8, 0.8));
	
	// Lumi?e ambiante
	mSceneMgr->setAmbientLight(Ogre::ColourValue(1, 1, 1));

	// [20150401] Sean, add
	//	- following 2 lines make bug clear
	// [20150404] Sean, add
	//	- 희안하게도 아래 두 줄을 막고 실행해도 이제 오류가 없다.
	//		단지 NVIDIA 제어판에서 texture filtering 관련된 기능 on만 시켰을 뿐인데.
	mSceneMgr->setShadowTechnique(Ogre::SHADOWTYPE_TEXTURE_ADDITIVE);
//	mSceneMgr->setShadowUseInfiniteFarPlane(false);


	// Sun
	Ogre::Light* Sun = mSceneMgr->createLight("Light0");
	Sun->setPosition(Ogre::Vector3(0,999000,0));
	Sun->setDiffuseColour(1, 1, 1);
	Sun->setSpecularColour(1, 0.9, 0.6);
}

void TestHydraXSkyX::InitHydrax(Ogre::RenderWindow* window, Ogre::Camera* camera)
{
	m_hydrax = new Hydrax::Hydrax(mSceneMgr, camera, window->getViewport(0));
	
	// Cr? le module Hydrax  <=> oc?n infini (technique de la grille projet?)

#if	1
	Hydrax::Module::ProjectedGrid *mModule 
		= new Hydrax::Module::ProjectedGrid(// Hydrax parent pointer
			                                m_hydrax,
											// Noise module
			                                new Hydrax::Noise::Perlin(),
											// Plan de base, de vecteur normal unit?y
			                                //Ogre::Plane(Ogre::Vector3(0,1,0), Ogre::Vector3(0,0,0)),
											Ogre::Plane(Ogre::Vector3::UNIT_Y, Ogre::Real(0.0f)),
											// Normal mode
											Hydrax::MaterialManager::NM_VERTEX,
											// Projected grid options
										    Hydrax::Module::ProjectedGrid::Options());
#else
	// [20150401] result is same 
	Hydrax::Module::SimpleGrid * mModule 
		= new Hydrax::Module::SimpleGrid(m_hydrax,new Hydrax::Noise::Perlin(),Hydrax::MaterialManager::NM_VERTEX,
		Hydrax::Module::SimpleGrid::Options());
#endif

	// Associe le module Hydrax ?l'objet Hydrax
	m_hydrax->setModule(static_cast<Hydrax::Module::Module*>(mModule));

	// Load all parameters from config file
	// Remarks: The config file must be in Hydrax resource group.
	// All parameters can be set/updated directly by code(Like previous versions),
	// but due to the high number of customizable parameters, since 0.4 version, Hydrax allows save/load config files.
	//m_hydrax->loadCfg("HydraxTest3.hdx");
	m_hydrax->loadCfg("FastWater.hdx");
//	m_hydrax->loadCfg("Hydrax051.hdx");		// for 0.511 version
//	m_hydrax->loadCfg("HydraxTest.hdx");	// for 0.54 community version

	
	m_hydrax->setShaderMode(Hydrax::MaterialManager::SM_CG);
//	m_hydrax->setShaderMode(Hydrax::MaterialManager::SM_HLSL);

	// Create water
    m_hydrax->create();


	m_hydrax->setSunPosition(Ogre::Vector3(0.0f,10000.0f,0.0f));
	m_hydrax->setSunColor(Ogre::Vector3(1.0f, 0.9f, 0.6f));

}

void TestHydraXSkyX::makeAnimationRoute()
{
	// get the distance from origin to this scene node
	Vector3		ScenePos		= GetSceneNode()->getPosition();
	Real		Radius			= ScenePos.distance( Vector3::ZERO );

	if( Radius == 0 )
		Radius		= 500;

	// accurary is the count of points (and lines)
	Ogre::Real const Accurary	= MAX_INDEX / 2;

	unsigned	nPointIndex	= 0;
	Vector3		vPos;

	// make waypoints
	for( Ogre::Real theta = 0; theta <= 2 * Math::PI; theta += Math::PI / Accurary )
	{
		vPos.x	= Radius * cos( theta );
		vPos.y	= ScenePos.y;
		vPos.z	= Radius * sin( theta );

		m_WalkList.push_back( vPos );

		if( nPointIndex == 0 )
		{
			// set initial position
			GetSceneNode()->setPosition( m_WalkList.front() );
			m_WalkList.pop_front();
		}
		else
		{
			//m_paTrack[ nPointIndex ]	= new CFighter( mSceneMgr, nPointIndex + 1, m_strMeshName );

			//// move fighter to destination
			//m_paTrack[ nPointIndex ]->MoveTo( m_aCirclePos[ nPointIndex - 1 ], m_aCirclePos[ nPointIndex ]);
		}
		nPointIndex++;

//		m_pCircle->position( vPos );
//		m_pCircle->index( nPointIndex++ );
	}
}

//-------------------------------------------------------------------------------------
void TestHydraXSkyX::createScene(void)
{
    m_Ship = mSceneMgr->createEntity("MEKOII", "MEKOII.mesh");

    m_ShipNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    m_ShipNode->attachObject(m_Ship);

	// 배가 물속에 잠기는 현상을 방지
	// FastWater.hdx를 사용할 때는 좀 더 높여줘야 함.
	m_ShipNode->translate(0, CAMERA_MIN_Y_ON_OCEAN, 0);

	makeAnimationRoute();

	/*
    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");
    l->setPosition(20,80,50);
	*/

	InitCamera();
	InitLight();
	InitHydrax(mWindow, mCamera);


	// ----------------------------------------------------------------------------
	// SkyX-related ptrs
	// ----------------------------------------------------------------------------

	// Set camera far/near clip distances
    mCamera->setFarClipDistance(30000);
	mCamera->setNearClipDistance(20);

	// Create our text area for display SkyX parameters
	createTextArea();

	// Create SkyX
	mBasicController = new SkyX::BasicController();
	mSkyX = new SkyX::SkyX(mSceneMgr, mBasicController);
	mSkyX->create();

	// Distance geometry falling is a feature introduced in SkyX 0.2
	// When distance falling is enabled, the geometry linearly falls with the distance and the
	// amount of falling in world units is determinated by the distance between the cloud field "plane"
	// and the camera height multiplied by the falling factor.
	// For this demo, a falling factor of two is good enough for the point of view we're using. That means that if the camera
	// is at a distance of 100 world units from the cloud field, the fartest geometry will fall 2*100 = 200 world units.
	// This way the cloud field covers a big part of the sky even if the camera is in at a very low altitude.
	// The second parameter is the max amount of falling distance in world units. That's needed when for example, you've an 
	// ocean and you don't want to have the volumetric cloud field geometry falling into the water when the camera is underwater.
	// -1 means that there's not falling limit.
	mSkyX->getVCloudsManager()->getVClouds()->setDistanceFallingParams(Ogre::Vector2(2,-1));

	// Register SkyX listeners
	mRoot->addFrameListener(mSkyX);
	mWindow->addListener(mSkyX);

//	mRenderingCamera = mCamera;

	setPreset(mPresets[mCurrentPreset]);

}

void TestHydraXSkyX::createFrameListener()
{
	BaseApplication::createFrameListener();
	
	// register keyboard and mouse event handler
	mKeyboard->setEventCallback(this);
	mMouse->setEventCallback(this);
}

void TestHydraXSkyX::chooseSceneManager()
{
	BaseApplication::chooseSceneManager();
}

bool TestHydraXSkyX::nextLocation(Real& distance)
{
	if(m_WalkList.empty())
	{
		return false;
	}

	mDestination = m_WalkList.front(); 
	m_WalkList.pop_front();

#if	1
	// loop indefinitely
	m_WalkList.push_back( mDestination );
#else
#endif
		
	mDirection	= mDestination - GetSceneNode()->getPosition();
	mDistance	= mDirection.normalise();

	distance	= mDirection.length();

	/*
	* for 부드러운 회전
	*/
	mSrcQuat	= GetSceneNode()->getOrientation();

	// @FIXME
	// 현재 B787.mesh가 -Z 방향이므로, 추후 Z 방향으로 수정 시 소스 수정
	mDestQuat		= Vector3(Vector3::UNIT_Z).getRotationTo (mDirection);
	mRotating		= false;
	mRotatingTime	= 0.0f;

	return true;
}

bool TestHydraXSkyX::MoveShip(const Ogre::FrameEvent& e)
{
//	MoveTo(m_aCirclePos[ 0 ], m_aCirclePos[ 1 ], evt);
	Real	waypointDistance;

	if(mDirection == Vector3::ZERO)
	{
		// set direction and distance to move for character
		if(nextLocation(waypointDistance))
		{
//			if( m_Trajectory )
//			{
//				m_Trajectory->addPoint( mDestination );
//				m_Trajectory->update();
//			}
		}

		// In the future move this into nextLocation
		m_ElapsedTime	= TIME_INTERVAL_1_SEC;
	}
	else if (mRotating)
	{
		/*
		* for 부드러운 회전
		*/

		/*
		* @FIXME
		* 가상전장환경에서 target 위치 정보는 0.5초 단위로 날라 온다.
		* 단지 이 예제에서 원을 이루는 각 구간 사이의 시간이 0.5초 미만으로
		*/
		static const Real	ROTATION_TIME	= TIME_INTERVAL_1_SEC;

		mRotatingTime		+= e.timeSinceLastFrame;
		mRotatingTime		= (mRotatingTime > ROTATION_TIME) ? ROTATION_TIME: mRotatingTime;

		Quaternion	delta	= Quaternion::Slerp(mRotatingTime / ROTATION_TIME, mSrcQuat, mDestQuat, true);

		GetSceneNode()->setOrientation (delta);

		if (mRotatingTime >= ROTATION_TIME)
		{
			mRotatingTime	= 0.0f;
			mRotating		= false;
		}
	}
	else
	{
		/////////////////////////////////////////////////////////////////////////////
		// FIX
		//	- 
		/////////////////////////////////////////////////////////////////////////////

		// calculate the distance to go
		Real move	= m_WalkSpeed * e.timeSinceLastFrame;

		// calculate the remaining distance
		mDistance	-= move;

		if(mDistance <= 0.0f/*m_ElapsedTime <= 0*/)
		{
			// if character reaches the waypoint
			// the remaining distance is less then zero
			GetSceneNode()->setPosition(mDestination);

			// clear direction to set the next waypoins
			mDirection = Vector3::ZERO;

			if(nextLocation(waypointDistance))
			{
				//////
				// add trajectory
				//////
//				if( m_Trajectory )
//				{
//					m_Trajectory->addPoint( mDestination );
//					m_Trajectory->update();
//				}

				///////////////////////////////////////////////////////////////
				// [20150116] Sean, B787 mesh가 현재 -Z 방향이다.
				///////////////////////////////////////////////////////////////
				Vector3 src = GetSceneNode()->getOrientation() * Vector3::UNIT_Z;

				// if angle of two vector is 180, then dot product is -1.
				if(1.0f + src.dotProduct(mDirection) < 0.0001f)
				{
					GetSceneNode()->yaw(Degree(180));
				}
				else
				{
					Ogre::Quaternion quat = src.getRotationTo(mDirection);
					GetSceneNode()->rotate(quat);
				}
			}

			// In the future move this into nextLocation
			m_ElapsedTime	= TIME_INTERVAL_1_SEC;
		}
		else
		{
			GetSceneNode()->translate(mDirection * move);
		}
	}

	/////////
	// call camera listener to move camera before node to move
	// 즉, chase camera가 아니다.
	/////////
//	if( m_CamListener )
//		m_CamListener->nodeUpdated( GetSceneNode(), evt );
	

	m_ElapsedTime	-= e.timeSinceLastFrame;

	return true;
}

bool TestHydraXSkyX::frameStarted(const FrameEvent &e)
{
	MoveShip(e);

    mKeyboard->capture();

	// Clamp camera height
	if (mCamera->getDerivedPosition().y < -400)
	{
		mCamera->setPosition(Ogre::Vector3(mCamera->getDerivedPosition().x, -400, mCamera->getDerivedPosition().z));
	}

	mKeyBuffer -= e.timeSinceLastFrame;

	return BaseApplication::frameStarted(e);

}

bool TestHydraXSkyX::frameRenderingQueued(const Ogre::FrameEvent& e)
{
	if (m_hydrax != NULL)
		m_hydrax->update(e.timeSinceLastFrame);

	return BaseApplication::frameRenderingQueued(e);
}

bool TestHydraXSkyX::keyPressed( const OIS::KeyEvent &arg )
{
	switch(arg.key)
	{
	case OIS::KC_1:
		// Switch presets
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 0;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_2:
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 1;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_3:
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 2;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_4:
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 3;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_5:
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 4;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_6:
		if (mKeyBuffer < 0)
		{
			mCurrentPreset = 5;
			setPreset(mPresets[mCurrentPreset]);

			mKeyBuffer = 0.25f;
		}
		break;
	case OIS::KC_7:
		break;
	case OIS::KC_8:
		break;
	case OIS::KC_9:
		break;
	default:
		break;
	}

	return BaseApplication::keyPressed( arg);
}

bool TestHydraXSkyX::keyReleased( const OIS::KeyEvent &arg )
{
	return BaseApplication::keyReleased( arg);
}

void TestHydraXSkyX::createTextArea()
{
	// Create a panel
	Ogre::OverlayContainer* panel = static_cast<Ogre::OverlayContainer*>(
		Ogre::OverlayManager::getSingleton().createOverlayElement("Panel", "TestHyraxSkyxPanel"));
	panel->setMetricsMode(Ogre::GMM_PIXELS);
	panel->setPosition(10, 10);
	panel->setDimensions(400, 400);

	// Create a text area
	mTextArea = static_cast<Ogre::TextAreaOverlayElement*>(
		OverlayManager::getSingleton().createOverlayElement("TextArea", "TestHyraxSkyxTextArea"));
	mTextArea->setMetricsMode(Ogre::GMM_PIXELS);
	mTextArea->setPosition(0, 0);
	mTextArea->setDimensions(100, 100);
	mTextArea->setCaption("TestHyraxSkyx");
	mTextArea->setCharHeight(16);
	mTextArea->setFontName("BlueHighway");
	mTextArea->setColourBottom(ColourValue(0.3, 0.5, 0.3));
	mTextArea->setColourTop(ColourValue(0.5, 0.7, 0.5));

	// Create an overlay, and add the panel
	Ogre::Overlay* overlay = OverlayManager::getSingleton().create("OverlayName");
	overlay->add2D(panel);

	// Add the text area to the panel
	panel->addChild(mTextArea);

	// Show the overlay
	overlay->show();
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        TestHydraXSkyX app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
