/*
-----------------------------------------------------------------------------
Filename:    CVisualX.h
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#ifndef __CVisualX_h_
#define __CVisualX_h_

#include "BaseApplication.h"
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#include "../res/resource.h"
#endif

#include "Sky.h"
#include "Ocean.h"
#include "Terrain.h"
#include "Target.h"
#include "Fighter.h"
#include "InputController.h"
#include "Config.h"


class CVisualX : public BaseApplication
{
public:
    CVisualX(void);
    virtual ~CVisualX(void);

protected:
	/**
	* @function		configure that load visualx configuration file
	*/
    virtual bool configure(void);

	/**
	 * @function		createViewport
	 * @remarks			BaseApplication 클래스에서 생성하는 
	 *					전체 스크린에 해당하는 main viewport 외에
	 *					인트로에 사용될 viewport를 생성한다.
	 */
    virtual void createViewports(void);
    virtual void createScene(void);
	void setupResources(void);

	/**
	* @function		createCamera that create input controller
	*/
    virtual void createCamera(void);
	virtual bool frameStarted( const FrameEvent &evt );
    virtual void createFrameListener(void);
    virtual bool frameRenderingQueued(const Ogre::FrameEvent& evt);

    virtual bool keyPressed(const OIS::KeyEvent &arg);
    virtual bool keyReleased(const OIS::KeyEvent &arg);
    virtual bool mouseMoved(const OIS::MouseEvent &arg);
    virtual bool mousePressed(const OIS::MouseEvent &arg, OIS::MouseButtonID id);
    virtual bool mouseReleased(const OIS::MouseEvent &arg, OIS::MouseButtonID id);

	/**
	* @function		CheckCollision
	* @return		true if camera is about to collide with any target
	*/
	bool CheckCollision(const Ogre::Vector3& position, const Ogre::Vector3& direction, 
		Ogre::Real& distToColl, Ogre::Vector3& hitPos);

protected:
	CSky*		m_pSky;
	COcean*		m_pOcean;
	CTerrain*	m_pTerrain;
	CInputController*	m_pInputController;

	/**
	* target container
	*
	* FIXME: 
	*	아마도 타겟은 아이디와 종류를 시뮬레이터로부터 
	*	받을 것 같다. 따라서 vector가 아니라 아이디를 키로 갖는 map 으로
	*	작성되어야 편리하다.
	*/
	typedef std::vector<CTarget*>	TARGET_LIST;
	TARGET_LIST		m_listTarget;

	Ogre::RaySceneQuery *mRaySceneQuery;
	MOC::CollisionTools*		m_pCollisionTools;
	bool		m_bCollision;

	CConfig		m_Config;

	void DeleteTargets();

	/**
	* @function		CallCreatePostprocess
	* @remarks		call CreatePostprocess of CTarget to 
	*				post processinf according to characteristic of each target
	*/
	void CallCreatePostprocess();

	///////////////////////////////////////////////////////////////////////////
	// ocean wave FX
	//////////////////////////////////////////////////////////////////////////////
	Ogre::GpuProgramPtr	  mActiveVertexProgram;
	Ogre::GpuProgramParametersSharedPtr mActiveVertexParameters;
	Ogre::MaterialPtr	  mActiveMaterial;
	Ogre::Pass*			  mActivePass;
	Ogre::GpuProgramPtr	  mActiveFragmentProgram;
	Ogre::GpuProgramParametersSharedPtr mActiveFragmentParameters;

	void controlWaveFreq(int nKey);
	///////////////////////////////////////////////////////////////////////////
	// intro
	///////////////////////////////////////////////////////////////////////////
	SceneNode*		m_snIntroTarget;

//	std::deque<SceneNode*>	m_IntroTargetList;

	Ogre::Camera*			m_IntroCamera;
	Ogre::Viewport*			m_IntroViewport;
	bool					m_IsIntro;	//< initial value is true.
	Real					m_RotTime;
	int						m_nIntroCurIndex;

	static const int		ROT_TIME	= 10;	//< rotate for 10 sec.


	void CreateIntroViewport();




	// derived from FrameListener via BaseApplication
	virtual void setupCameraPosition();

	void ControlCameraDistance(Ogre::Camera* pCamera, Ogre::Entity* pEntity)
	{
		// move camera to initial position
		setupCameraPosition();

		// getWorldBoundingBox() and getWorldBoundingBox( true ) return a different value
  		Ogre::AxisAlignedBox modelBoundsBox	= pEntity->getWorldBoundingBox( true );

		if( pCamera == NULL || pEntity == NULL /*|| modelBoundsBox.isFinite() || modelBoundsBox.isNull()*/)
			return;

		Ogre::Vector3			center	= modelBoundsBox.getCenter();//(modelBoundsBox.getMaximum() - modelBoundsBox.getMinimum()) / 2 + modelBoundsBox.getMinimum();//modelBoundsBox.getCenter();

		pCamera->lookAt( center );
		
		const Ogre::Vector3*	corners	= modelBoundsBox.getAllCorners();
		const Ogre::Matrix4		viewMatrix	= pCamera->getViewMatrix();
		Ogre::Vector3			screenCorner;

		Real	min_x =	1.0, max_x = 0.0, min_y = 1.0, max_y = 0.0, min_dim = 1.0, max_dim = 0.0;

		for( int i = 0 ; i < 7; i++ )
		{
			screenCorner	= corners[i];
			screenCorner	= viewMatrix * screenCorner;

			Real	x		= screenCorner.x / screenCorner.z + 0.5;
			Real	y		= screenCorner.y / screenCorner.z + 0.5;

			if( x < min_x )
				min_x	= x;
			if( x > max_x )
				max_x	= x;
			if( y < min_y )
				min_y	= y;
			if( y > max_y )
				max_y	= y;
			if( min_x < min_dim )
				min_dim	= min_x;
			if( min_y < min_dim )
				min_dim	= min_y;
			if( max_x > max_dim )
				max_dim	= max_x;
			if( max_y > max_dim )
				max_dim	= max_y;
		}

		Real	width	= (max_x - min_x);
		Real	height	= (max_y - min_y);
		Real	longdimension;

		if( width > height )
			longdimension	= width;
		else
			longdimension	= height;

		// move the camera according to axis of camera coordinate
		if( longdimension > 1.2 )
		{
			Real	d	= (longdimension - 0.9) * 200.0;

			// move backward
			pCamera->moveRelative(Ogre::Vector3(0, 0, d));
		}
		else if( longdimension < 0.8 )
		{
			Real	d	= (1-(0.8/longdimension)) * 10.0;

			// move forward
			pCamera->moveRelative(Ogre::Vector3(0, 0, d));
		}
	}

	/**
	* @function		SetNextIntroTarget
	* @remark		get the next target from target list and 
	*				set the target to next intro target
	*/
	void SetNextIntroTarget()
	{
		// set the previous invisible
		if( m_snIntroTarget )
			m_snIntroTarget->setVisible( false );

		// get next target and set visible
		if( m_listTarget.size() > 0 && m_nIntroCurIndex < m_listTarget.size() )
		{
			CTarget*	pSC	= m_listTarget[m_nIntroCurIndex];

			if( pSC )
				m_snIntroTarget		= pSC->GetSceneNode();

			////////////////////////////////////////////////////////////////////////////
			// check the target size and control the distance between the camera and target
			////////////////////////////////////////////////////////////////////////////
			Entity*	pTemp		= static_cast<Entity*>(m_snIntroTarget->getAttachedObject(0));

			ControlCameraDistance(m_IntroCamera, pTemp);

			m_snIntroTarget->setVisible( true );

			m_nIntroCurIndex++;
		}
		else
		{
			m_snIntroTarget		= NULL;

			// finalize the intro
			SetIntroEnd();
		}

		m_RotTime	= ROT_TIME;
	}

	/**
	* @function		SetIntroEnd
	* @remark		finalize intro mode. set intro flag to false and
	*				delete intro viewport
	*/
	void SetIntroEnd()
	{
		// delete intro viewport
		mWindow->removeViewport( 1 );

		// set flag to false
		m_IsIntro	= false;

		// keep creating other characters (ocean, sky, ans so on)
		createScene();
	}


};

#endif // #ifndef __CVisualX_h_
