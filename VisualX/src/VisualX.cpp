/*
-----------------------------------------------------------------------------
Filename:    CVisualX.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.8.x Application Wizard for VC10 (May 2012)
      https://bitbucket.org/jacmoe/ogreappwizards
-----------------------------------------------------------------------------
*/
#include "StdAfx.h"
#include "CollisionTools.h"
#include "VisualX.h"

const int	MAX_TARGET	= 50;
const int	MAX_CAMERA_COLLISION_DISTANCE	= 50;

/**
* define space of battle field
*/

const int	MAX_Y		= 1000;					/** elevation */
const int	MAX_X		= COcean::MAX_WIDTH;	/** width */
const int	MAX_Z		= COcean::MAX_HEIGHT;	/** height */

//-------------------------------------------------------------------------------------
CVisualX::CVisualX(void) :
	m_pOcean(NULL), m_pSky(NULL), m_pTerrain(NULL), m_pInputController(NULL),
	m_bCollision(false), m_pCollisionTools(NULL)
{
}
//-------------------------------------------------------------------------------------
CVisualX::~CVisualX(void)
{
	DEL(m_pOcean);
	DEL(m_pSky);
	DEL(m_pTerrain);
	DEL(m_pInputController);

	
	// delete all targets
	std::list<CTarget*>::iterator	it;

	while( !m_listTarget.empty() )
	{
		CTarget*	pTarget	= m_listTarget.front();
		m_listTarget.pop_front();

		DEL(pTarget);
	}

	DEL( m_pCollisionTools );
}

//-------------------------------------------------------------------------------------
void CVisualX::createScene(void)
{
    Ogre::Entity* ogreHead = mSceneMgr->createEntity("Head", "ogrehead.mesh");

    Ogre::SceneNode* headNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    headNode->attachObject(ogreHead);

    // Set ambient light
    mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

    // Create a light
    Ogre::Light* l = mSceneMgr->createLight("MainLight");

    l->setPosition(20,80,50);

	/**
	* create entities for battlefield
	*/


	/************ NOTE *********
	* change followings
	*/
	////////////////////////////////////////////////
	// create sky
	////////////////////////////////////////////////
	mRenderingCamera	= mCamera;

	m_pSky		= new (nothrow) CSky(mSceneMgr);

	if( m_pSky )
		m_pSky->createScene();

	// Register SkyX listeners
	mRoot->addFrameListener(mSkyX);
	mWindow->addListener(mSkyX);

	setPreset(mPresets[mCurrentPreset]);

	////////////////////////////////////////////////
	// create terrain
	////////////////////////////////////////////////
	m_pTerrain		= new (nothrow) CTerrain(mSceneMgr, mCamera);

	if( m_pTerrain )
	{
		m_pTerrain->createScene();
		m_pTerrain->createFrameListener();
	}

	////////////////////////////////////////////////
	// create ocean
	////////////////////////////////////////////////

	m_pOcean	= new (nothrow) COcean(mSceneMgr);

	if( m_pOcean )
		m_pOcean->createScene();

	/***************************************************
	* create targets
	***************************************************/
	srand( (unsigned)time( NULL ) );

	for(int i = 0; i < MAX_TARGET; i++)
	{
		CTarget*	pTarget	= new (nothrow) CTarget(mSceneMgr, i, "ogrehead.mesh");

		assert(pTarget);

		/**
		* locate the target around the camera
		*/
		Ogre::Vector3	position	= mCamera->getPosition();
		int				nRangeMin	= 0;
		int				nRangeMax	= 1000;

		pTarget->setPosition((float)rand() / (RAND_MAX + 1) * (nRangeMax - nRangeMin) + position.x, 
#if	0
			(float)rand() / (RAND_MAX + 1) * (nRangeMax - nRangeMin) + position.y, 
#else
			/* for interference test with ocean */
			m_pOcean->GetSurface() - 10, 
#endif
			(float)rand() / (RAND_MAX + 1) * (nRangeMax - nRangeMin) + position.z);

		m_listTarget.push_back(pTarget);

		/* add frame listener */
		pTarget->createFrameListener();
	}

//	m_pInputController	= new (nothrow) CInputController(mRoot, mKeyboard, mMouse);
	if( m_pInputController )
		/* add frame listener */
		m_pInputController->createFrameListener();

	///////////////////////////////////////////////////////////////////////////
	// create CollisionTools
	///////////////////////////////////////////////////////////////////////////
	m_pCollisionTools	= new (nothrow) MOC::CollisionTools( mSceneMgr );

	if( m_pCollisionTools )
	{
		// error case. log it.
	}

//#ifdef	_DEBUG
	// make xyz-axis for debugging
	Ogre::Entity* mAxesEntity = mSceneMgr->createEntity("Axes", "axes.mesh");
	mSceneMgr->getRootSceneNode()->createChildSceneNode("AxesNode",Ogre::Vector3(0,0,0))->attachObject(mAxesEntity);
	mSceneMgr->getSceneNode("AxesNode")->setScale(50, 50, 50);
//#endif
}

void CVisualX::setupResources(void)
{
	// load base class's resources
	BaseApplication::setupResources();

	/** add my own resource location */
	Ogre::ResourceGroupManager::getSingleton().addResourceLocation("./resource",
		"FileSystem");

	// following call cause assertion fails.
	// BaseApplication::loadResources() function has following call.
//	Ogre::ResourceGroupManager::getSingleton().initialiseAllResourceGroups();
}

void CVisualX::createFrameListener(void)
{
	// add base frame listener
	BaseApplication::createFrameListener();
	// Add frame listener
//	mRoot->addFrameListener(new SkyXDemoFrameListener(mWindow, mCamera, mSceneMgr));

	mMouse->setEventCallback(this);
    mKeyboard->setEventCallback(this);

	// create ray scene query for collision detection
	mRaySceneQuery = mSceneMgr->createRayQuery(Ogre::Ray());
}

bool CVisualX::frameStarted( const FrameEvent &evt )
{

	return BaseApplication::frameStarted( evt );
}
    
bool CVisualX::frameRenderingQueued(const Ogre::FrameEvent& evt)
{
	Ogre::Real		distToColl	= 0;
	Ogre::Vector3	camPos		= mCamera->getPosition();
	Ogre::Ray		camRay(Ogre::Vector3(camPos.x, 5000.0f, camPos.z), Ogre::Vector3::NEGATIVE_UNIT_Y);
	Ogre::Vector3	hitPos		= Ogre::Vector3::ZERO;
	Ogre::Entity*	pEntity		= NULL;

	if( m_pCollisionTools->raycast( camRay, hitPos, pEntity, distToColl ))
	{
		DebugPrintf("Debug: collision detected: dist: %f, hit pos: (%f, %f, %f), cam pos: (%f, %f, %f)",
			distToColl, hitPos.x, hitPos.y, hitPos.z, camPos.x, camPos.y, camPos.z );

		if(( hitPos == camPos ) || hitPos.y > camPos.y )
			mCamera->setPosition( camPos.x, hitPos.y + 100, camPos.z );
		else
		{
			if( distToColl < 100.0f )
				// camera is about to collide with any thing
				// stop the camera or move the camera to avoid the collision here
				mCamera->setPosition( camPos.x, camPos.y + 100, camPos.z );
		}
	}
	else
	{
		/** CheckCollision function do *NOT* work on the plane(ocean). */
		if( camPos.y <= m_pOcean->GetSurface() )
			mCamera->setPosition( camPos.x, m_pOcean->GetSurface() + 100, camPos.z );
	}


//	if( CheckCollision( camPos, Ogre::Vector3::NEGATIVE_UNIT_Y, distToColl, hitPos ) == true )
	//{
	//	DebugPrintf("Debug: collision detected: dist: %f, hit pos: (%f, %f, %f), cam pos: (%f, %f, %f)",
	//		distToColl, hitPos.x, hitPos.y, hitPos.z, camPos.x, camPos.y, camPos.z );

	//	if( distToColl < 100.0f )
	//		// camera is about to collide with any thing
	//		// stop the camera or move the camera to avoid the collision here
	//		mCamera->setPosition( camPos.x, camPos.y + 100, camPos.z );
	//}

	return BaseApplication::frameRenderingQueued( evt );
}

bool CVisualX::keyPressed(const OIS::KeyEvent &arg)
{
	switch(arg.key)
	{
	case OIS::KC_W:
	case OIS::KC_UP:
		if( m_bCollision )
			return true;
	default:
		break;
	}

	return BaseApplication::keyPressed(arg);
}

bool CVisualX::keyReleased(const OIS::KeyEvent &arg)
{
	return BaseApplication::keyReleased(arg);
}

/**
* @function		CheckCollision
* @return		true if camera is about to collide with any target except the plane (ocean).
*/
bool  CVisualX::CheckCollision(const Ogre::Vector3& position, const Ogre::Vector3& direction, 
	Ogre::Real& distToColl, Ogre::Vector3& hitPos)
{
	if( m_pCollisionTools )
	{
		Ogre::Entity*	target	= NULL;

//		position + direction * Ogre::Vector3(3,3,3);
		if( m_pCollisionTools->raycastFromPoint( position, direction, hitPos, target, distToColl ))
		{
			return true;
		}

		return false;
	}

    Ogre::Ray ray(position, direction);

    mRaySceneQuery->setRay(ray);
	mRaySceneQuery->setSortByDistance(true);
	mRaySceneQuery->setQueryMask(0xFFFFFFFF);	/** catch any entity */

    Ogre::RaySceneQueryResult &result = mRaySceneQuery->execute();

    Ogre::RaySceneQueryResult::iterator itr;

	int	i = 0;
    for (itr = result.begin(); itr != result.end(); itr++, i++) 
	{
		DebugPrintf("distance[%d]: %f", i, itr->distance);
		/* NOTE
		* distance between two frames is 1459.913086 (shift+w key).
		* so collision distance is bigger than 1459.913086. <--- maybe WRONG!!!
		*/
		if( itr->distance != 0 && itr->distance < 1500 )
			return true;

		//if( itr->worldFragment->singleIntersection.distance() )
		//{
		//	return true;
		//}
    }

	return false;
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        CVisualX app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
